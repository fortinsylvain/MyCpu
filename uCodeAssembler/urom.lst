                              ; -----------------------------------------------------------------
                              ; Homebrew CPU micro code
                              ; Author: Sylvain Fortin  sylfortin71@hotmail.com
                              ; Date : 21 march 2025
                              ; Documentation : uCode stored in 2 binary file to be 
                              ;                 programmed into 2864 to control the 74LSxx based 
                              ;                 cpu.
                              ; External RAM required to support the microcode
                              ; 0000H - 17FFH Total RAM space
                              ; 0000H - 00FFH Stack
                              ; 0100H - 17EF  Free for application
                              ; 1FF0H SP      Stack Pointer 8 bit
                              ; 1FF1H JSH     Temporary storage for JSR MSB address
                              ; 1FF2H JSL          "       "     "   "  LSB    "
                              ; 1FF3H X MSB   X Register MSB
                              ; 1FF4H X LSB   X Register LSB
                              ; 1FFAH E       bit<0> Equal Status bit. Set if the result is 0 otherwise cleared
                              ; 1FFBH C       bit<0> Carry Status bit
                              ; 1FFCH A       A Register
                              ; 1FFEH IPH	    Instruction Pointer MSB
                              ; 1FFFH IPL          "         "    LSB
                              ; C000H         LED port
                              ; E000H - F000H EEPROM for application program
                              ; -----------------------------------------------------------------
                              ORG/0000H    ; 0000H   RESET
0000       2900               00H>R1
0001       2800               00H>R0       ; Dummy Instruction
0002       2800               00H>R0       ; Stack Pointer Init
0003       781F               1FH>AH       ; Stack Start : 0000H
0004       68F0               F0H>AL       ; Stack Max   : 00FFH
0005       5800               R0>DATA
0006       78FF               FFH>AH       ; Get [FFFE] MSB Start Vector
0007       68FE               FEH>AL
0008       2000               DATA>R0
0009       781F               1FH>AH       ; MSB Start Vector Stored in IPH
000A       68FE               FEH>AL
000B       5800               R0>DATA
000C       78FF               FFH>AH       ; Get [FFFF] LSB Start Vector
000D       68FF               FFH>AL
000E       2100               DATA>R1
000F       781F               1FH>AH       ; LSB Start Vector Stored in IPL
0010       68FF               FFH>AL
0011       5900               R1>DATA 
0012       3001               01H>UH       ; Get Pointed OP Code and Execute
0013       3800               00H>UL
0014       C800               JMP          ; ***************************************************
                              ORG/0080H    ; 0100H Get Pointed OP Code by IP and Execute
0100       781F               1FH>AH       ; Read IPH
0101       68FE               FEH>AL
0102       2000               DATA>R0
0103       68FF               FFH>AL       ; Read IPL
0104       2100               DATA>R1      
0105       1000               R0>AH        ; Write IPH:IPL in AH:AL
0106       1900               R1>AL
0107       2300               DATA>R3      ; Read OP. Code
0108       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
0109       3800               00H>UL       ;          |
010A       2C01               01H>R4       ;  IP+1>IP | ADD. RETURN
010B       2D0D               0DH>R5       ;  IP>ADD  |
010C       C800               JMP          ;          | JMP TO ROUTINE
010D       0300               R3>UH        ; Build micro address and execute OP. code
010E       3800               00H>UL
010F       C800               JMP          ; ***************************************************
                              ORG/0100H    ; 0200H Take Next OP Code and Execute
0200       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
0201       3800               00H>UL       ;          |
0202       2C02               02H>R4       ;  IP+1>IP | ADD. RETURN
0203       2D05               05H>R5       ;  IP>ADD  |
0204       C800               JMP          ;          | JMP TO ROUTINE
0205       2300               DATA>R3      ; Read OP. Code
0206       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
0207       3800               00H>UL       ;          |
0208       2C01               01H>R4       ;  IP+1>IP | ADD. RETURN
0209       2D0D               0DH>R5       ;  IP>ADD  | JMP TO ROUTINE
020A       C800               JMP          ; ***************************************************
                              ORG/0300H    ; OP.06 JSR    Jump to SubRoutine
0600       2000               DATA>R0      ; Read MSB IP Destination
0601       781F               1FH>AH       ; Store in JSH (Temp SP1) MSB
0602       68F1               F1H>AL       
0603       5800               R0>DATA  
0604       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
0605       3800               00H>UL       ;          |
0606       2C06               06H>R4       ;  IP+1>IP | ADD. RETURN
0607       2D09               09H>R5       ;  IP>ADD  |
0608       C800               JMP          ;          | JMP TO ROUTINE
0609       2000               DATA>R0      ; Read LSB IP Destination
060A       781F               1FH>AH       ; Store in JSL (Temp SP2) LSB
060B       68F2               F2H>AL
060C       5800               R0>DATA
060D       303C               3CH>UH       ;  IP+1>IP | ADDRESS OF ROUTINE TO INCREMENT IP
060E       3800               00H>UL       ;          | Compute return address from routine
060F       2C06               06H>R4       ;          | R4 R5 Add. Return for uProgram         
0610       2D12               12H>R5
0611       C800               JMP
0612       781F               1FH>AH       ; Read STACK POINTER Register (SP) (8bit LSB) MSB=0H Always
0613       68F0               F0H>AL
0614       2000               DATA>R0
0615       68FE               FEH>AL       ; Read IPH Return Adress
0616       2100               DATA>R1
0617       7800               00H>AH       ; Put in STACK
0618       1800               R0>AL
0619       5900               R1>DATA
061A       781F               1FH>AH       ; Read SP Register
061B       68F0               F0H>AL
061C       2000               DATA>R0
061D       303E               3EH>UH       ; Increment R0 containing SP value
061E       3800               00H>UL       ; R0+1>R0  | ADD. Incrementation Routine
061F       2E06               06H>R6       ;          | ADD. Return
0620       2F22               22H>R7
0621       C800               JMP
0622       5800               R0>DATA      ; Put Result in SP Register
0623       68FF               FFH>AL       ; Read IPL for subroutine return
0624       2100               DATA>R1
0625       7800               00H>AH       ; Put value of SP on address bus
0626       1800               R0>AL        
0627       5900               R1>DATA      ; Store IPL return on Stack
0628       303E               3EH>UH       ; Increment R0 containing SP value
0629       3800               00H>UL       ; R0+1>R0  | ADD. Incrementation Routine
062A       2E06               06H>R6       ;          | ADD. Return
062B       2F2D               2DH>R7
062C       C800               JMP
062D       781F               1FH>AH       ; Store new value in SP Register
062E       68F0               F0H>AL
062F       5800               R0>DATA
0630       781F               1FH>AH       ; Read JSH stored MSB address of routine to execute
0631       68F1               F1H>AL
0632       2000               DATA>R0
0633       68FE               FEH>AL       ; Write MSB address routine in IPH
0634       5800               R0>DATA
0635       781F               1FH>AH       ; Read JSL stored LSB address of routine to execute
0636       68F2               F2H>AL
0637       2000               DATA>R0
0638       68FF               FFH>AL       ; Write LSB address routine in IPL
0639       5800               R0>DATA
063A       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
063B       3800               00H>UL
063C       C800               JMP          ; ***************************************************
                              ORG/0380H    ; OP.07 RTS    ReTurn from Subroutine
0700       781F               1FH>AH       ; Read Stack Pointer Register
0701       68F0               F0H>AL
0702       2000               DATA>R0
0703       303A               3AH>UH       ;          | ADD. Routine R0-1>R0
0704       3800               00H>UL       ; SP-1     |
0705       2E07               07H>R6       ;          | ADD. return
0706       2F08               08H>R7       ; Decrementing the Stack Pointer Register
0707       C800               JMP
0708       7800               00H>AH       ; Read from Stack return address IPL
0709       1800               R0>AL
070A       2100               DATA>R1
070B       781F               1FH>AH       ; Store in IPL Register
070C       68FF               FFH>AL
070D       5900               R1>DATA
070E       303A               3AH>UH       ;          | ADD. Routine R0-1>R0
070F       3800               00H>UL       ; SP-1     |
0710       2E07               07H>R6       ;          | ADD. return
0711       2F13               13H>R7       ; Again decrementing the Stack Pointer Register
0712       C800               JMP
0713       68F0               F0H>AL       ; Store in SP register
0714       5800               R0>DATA
0715       7800               00H>AH       ; Read from Stack return address IPH
0716       1800               R0>AL
0717       2100               DATA>R1
0718       781F               1FH>AH       ; Store in IPH Register
0719       68FE               FEH>AL
071A       5900               R1>DATA
071B       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
071C       3800               00H>UL
071D       C800               JMP          ; ***************************************************
                              ORG/0400H    ; OP.08 STOP   STOP MICROPROGRAM EXECUTION
0800       3008               08H>UH
0801       3802               02H>UL
0802       C800               JMP          ; ***************************************************
                              ORG/0480H    ; OP.09 NOP    No OPeration
0900       3001               01H>UH       ; Go execute currently pointed OP.
0901       3800               00H>UL
0902       C800               JMP          ; ***************************************************
                              ORG/0500H    ; OP.0A LDA (X) Load Reg A Indexed
0A00       781F               1FH>AH       ; Read X MSB
0A01       68F3               F3H>AL
0A02       2200               DATA>R2
0A03       68F4               F4H>AL       ; Read X LSB
0A04       2300               DATA>R3
0A05       1200               R2>AH        ; Put on addres bus
0A06       1B00               R3>AL
0A07       2000               DATA>R0      ; Read pointed byte
0A08       781F               1FH>AH       ; Write in register A
0A09       68FC               FCH>AL   
0A0A       5800               R0>DATA
0A0B       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
0A0C       3800               00H>UL
0A0D       C800               JMP          ; ***************************************************
                              ORG/0580H    ; OP.0B STA (X) Store Reg A Indexed
0B00       781F               1FH>AH       ; Read X MSB
0B01       68F3               F3H>AL
0B02       2200               DATA>R2
0B03       68F4               F4H>AL       ; Read X LSB
0B04       2300               DATA>R3
0B05       68FC               FCH>AL       ; Read Reg A
0B06       2400               DATA>R4
0B07       1200               R2>AH        ; Set address bus
0B08       1B00               R3>AL
0B09       5C00               R4>DATA      ; Write
0B0A       3002               02H>UH       ; Next OP.
0B0B       3800               00H>UL
0B0C       C800               JMP          ; ***************************************************
                              ORG/0600H    ; OP.0C JRA **H Unconditional relative jump
0C00       2000               DATA>R0      ; Read the displacement
0C01       5007               R0-7>A       ; Check sign bit <7>
0C02       300C               0CH>UH
0C03       3840               40H>UL
0C04       C81B               JMP_A=0      ; if bit 7 is 0 then we jump foward,
0C05       781F               1FH>AH       ; Else jump backward
0C06       68FF               FFH>AL       ; Read IPL
0C07       2100               DATA>R1
0C08       2A01               01H>R2       ; Put Cin(R2-0)=1
0C09       303F               3FH>UH       ;           | ADD. ROUTINE
0C0A       3800               00H>UL       ; R0+R1>R0  |
0C0B       2E0C               0CH>R6       ; Cout>R2-0 | RETURN ADDRESS
0C0C       2F0E               0EH>R7
0C0D       C800               JMP
0C0E       5800               R0>DATA      ; Store IPL
0C0F       68FE               FEH>AL       ; Read IPH
0C10       2000               DATA>R0
0C11       29FF               FFH>R1       ; Sign extension
0C12       303F               3FH>UH       ; Cin(R2-0) | ADD. ROUTINE
0C13       3800               00H>UL       ; R0+R1>R0  |
0C14       2E0C               0CH>R6       ; Cout>R2-0 | RETURN ADDRESS
0C15       2F17               17H>R7
0C16       C800               JMP
0C17       5800               R0>DATA      ; Store IPH
0C18       3001               01H>UH       ; Go execute currently pointed OP.
0C19       3800               00H>UL
0C1A       C800               JMP
                              ORG/0640H
0C40       781F               1FH>AH       ; Read IPL >>Jump forward arrive here<<
0C41       68FF               FFH>AL       
0C42       2100               DATA>R1
0C43       2A01               01H>R2       ; Put Cin(R2-0)=1 to jump relative to next instruction
0C44       303F               3FH>UH       ;           | ADD. ROUTINE
0C45       3800               00H>UL       ; R0+R1>R0  |
0C46       2E0C               0CH>R6       ; Cout>R2-0 | RETURN ADDRESS
0C47       2F49               49H>R7
0C48       C800               JMP
0C49       5800               R0>DATA      ; Store IPL
0C4A       5200               R2-0>A       ; Add 1 to IPH only if there is a carry
0C4B       3001               01H>UH       ; If Cout=0 no increment on IPH
0C4C       3800               00H>UL       ; and go execute currently pointed OP.
0C4D       C81B               JMP_A=0      
0C4E       68FE               FEH>AL       ; else Cout=1 then we increment IPH
0C4F       2000               DATA>R0      ; Read IPH
0C50       303E               3EH>UH       ; R0+1>R0
0C51       3800               00H>UL       ; Cout>R1-7
0C52       2E0C               0CH>R6       ; Return
0C53       2F55               55H>R7
0C54       C800               JMP
0C55       5800               R0>DATA      ; Store IPH
0C56       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
0C57       3800               00H>UL
0C58       C800               JMP          ; ***************************************************
                              ORG/0680H    ; OP.0D SRLA   Shift Right Logical on Reg A
0D00       781F               1FH>AH       ;              0 -> b7 b6 b5 b4 b3 b2 b1 b0 -> C
0D01       68FC               FCH>AL
0D02       2000               DATA>R0      ; Read A Register and store in R0
0D03       2900               00H>R1       ; Clear Register R1 to insert a '0' in bit 7
0D04       5100               R1-0>A
0D05       481F               A>Q7
0D06       5007               R0-7>A       ; shift bit 6:1 to 5:0, result in Q
0D07       481E               A>Q6
0D08       5006               R0-6>A
0D09       481D               A>Q5
0D0A       5005               R0-5>A
0D0B       481C               A>Q4
0D0C       5004               R0-4>A
0D0D       481B               A>Q3
0D0E       5003               R0-3>A
0D0F       481A               A>Q2
0D10       5002               R0-2>A
0D11       4819               A>Q1
0D12       5001               R0-1>A
0D13       4818               A>Q0
0D14       6200               Q>R2         ; Transfer shifted result into R2
0D15       5A00               R2>DATA      ; Store result in Register A
0D16       5100               R1-0>A       ; Clear Q[7:1]
0D17       481F               A>Q7
0D18       481E               A>Q6
0D19       481D               A>Q5
0D1A       481C               A>Q4
0D1B       481B               A>Q3
0D1C       481A               A>Q2
0D1D       4819               A>Q1
0D1E       5000               R0-0>A       ; Get bit 0 of original value before shifting
0D1F       4818               A>Q0         ; b0 -> C
0D20       6300               Q>R3         ; Store Carry in R3
0D21       68FB               FBH>AL       ; Save to the Carry Status Register
0D22       5B00               R3>DATA
0D23       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
0D24       3800               00H>UL
0D25       C800               JMP          ; ***************************************************
                              ORG/0700H    ; OP.0E SLLA/SLAA  Shift Left Logical/Arithmetic 
0E00       781F               1FH>AH       ;              C <- b7 b6 b5 b4 b3 b2 b1 b0 <- 0
0E01       68FC               FCH>AL
0E02       2000               DATA>R0      ; Read A Register and store in R0
0E03       2900               00H>R1       ; Clear Register R1 to insert a '0' in bit 0
0E04       5100               R1-0>A
0E05       4818               A>Q0
0E06       5000               R0-0>A       ; shift bit 6:0 to 7:1, result in Q
0E07       4819               A>Q1
0E08       5001               R0-1>A
0E09       481A               A>Q2
0E0A       5002               R0-2>A
0E0B       481B               A>Q3
0E0C       5003               R0-3>A
0E0D       481C               A>Q4
0E0E       5004               R0-4>A
0E0F       481D               A>Q5
0E10       5005               R0-5>A
0E11       481E               A>Q6
0E12       5006               R0-6>A
0E13       481F               A>Q7
0E14       6200               Q>R2         ; Transfer shifted result into R2
0E15       5A00               R2>DATA      ; Store result in Register A
0E16       5100               R1-0>A       ; Clear Q[7:1]
0E17       481F               A>Q7
0E18       481E               A>Q6
0E19       481D               A>Q5
0E1A       481C               A>Q4
0E1B       481B               A>Q3
0E1C       481A               A>Q2
0E1D       4819               A>Q1
0E1E       5007               R0-7>A       ; Get bit 7 of original value before shifting
0E1F       4818               A>Q0         ; b7 -> C
0E20       6300               Q>R3         ; Store Carry in R3
0E21       68FB               FBH>AL       ; Save to the Carry Status Register
0E22       5B00               R3>DATA
0E23       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
0E24       3800               00H>UL
0E25       C800               JMP          ; ***************************************************
                              ORG/0780H    ; OP.0F JRNC
0F00       781F               1FH>AH       ; Read C bit and put in A ALU input
0F01       68FB               FBH>AL
0F02       2000               DATA>R0
0F03       5000               R0-0>A
0F04       300F               0FH>UH       ; if C = 0 then prepare the jump JRA
0F05       380A               0AH>UL
0F06       C81B               JMP_A=0
0F07       3002               02H>UH       ; NEXT OP.
0F08       3800               00H>UL
0F09       C800               JMP          
0F0A       68FE               FEH>AL       ; Put IP on Address Bus
0F0B       2000               DATA>R0
0F0C       68FF               FFH>AL
0F0D       2100               DATA>R1
0F0E       1000               R0>AH
0F0F       1900               R1>AL
0F10       300C               0CH>UH       ; do the JRA
0F11       3800               00H>UL
0F12       C800               JMP          ; ***************************************************
                              ORG/0800H    ; OP.10 RRCA Rotate Right Logical Reg A through C
1000       781F               1FH>AH       ;            C -> b7 b6 b5 b4 b3 b2 b1 b0 -> C
1001       68FC               FCH>AL
1002       2000               DATA>R0      ; Read A Register and store in R0
1003       68FB               FBH>AL       ; Read Carry and put in R1
1004       2100               DATA>R1
1005       5100               R1-0>A       ; Take Carry from Register R1 and insert in bit 7
1006       481F               A>Q7
1007       5007               R0-7>A       ; shift bit 6:1 to 5:0, result in Q
1008       481E               A>Q6
1009       5006               R0-6>A
100A       481D               A>Q5
100B       5005               R0-5>A
100C       481C               A>Q4
100D       5004               R0-4>A
100E       481B               A>Q3
100F       5003               R0-3>A
1010       481A               A>Q2
1011       5002               R0-2>A
1012       4819               A>Q1
1013       5001               R0-1>A
1014       4818               A>Q0
1015       6200               Q>R2         ; Store shifted result in R2
1016       68FC               FCH>AL       ; Store result in Register A
1017       5A00               R2>DATA
1018       2B00               00H>R3       ; Clear Q[7:1]
1019       5300               R3-0>A       
101A       481F               A>Q7
101B       481E               A>Q6
101C       481D               A>Q5
101D       481C               A>Q4
101E       481B               A>Q3
101F       481A               A>Q2
1020       4819               A>Q1
1021       5000               R0-0>A       ; Get bit 0 of original value before shifting
1022       4818               A>Q0         ; b0 -> C
1023       6400               Q>R4         ; Store Carry in R4
1024       68FB               FBH>AL       ; Save to the Carry Status Register
1025       5C00               R4>DATA
1026       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
1027       3800               00H>UL
1028       C800               JMP          ; ***************************************************
                              ORG/0880H    ; OP.11 RCF  Reset Carry Flag  Carry <- 0 
1100       2800               00H>R0       ; clear all bits in R0
1101       781F               1FH>AH       ; Write in carry satus bit
1102       68FB               FBH>AL
1103       5800               R0>DATA
1104       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
1105       3800               00H>UL
1106       C800               JMP          ; ***************************************************
                              ORG/0900H    ; OP.12 SCF  Set Carry Flag  Carry <- 1
1200       2801               01H>R0       ; Set carry flag
1201       781F               1FH>AH       ; Write in carry satus bit
1202       68FB               FBH>AL
1203       5800               R0>DATA
1204       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
1205       3800               00H>UL
1206       C800               JMP          ; ***************************************************
                              ORG/1400H    ; OP.28 ADCA ****H  A + C + BYTE AT ADDRESS, C UP
2800       2200               DATA>R2      ; READ MSB ADDRESS
2801       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
2802       3800               00H>UL       ;          |
2803       2C28               28H>R4       ;  IP+1>IP | ADD. RETURN
2804       2D06               06H>R5       ;  IP>ADD  |
2805       C800               JMP          ;          | JMP TO ROUTINE
2806       2300               DATA>R3      ; READ LSB ADDRESS
2807       1200               R2>AH        ; PUT ADDRESS ON ADDRESS BUS
2808       1B00               R3>AL
2809       2000               DATA>R0      ; READ POINTED BYTE
280A       781F               1FH>AH       ; READ REG A
280B       68FC               FCH>AL   
280C       2100               DATA>R1
280D       781F               1FH>AH       ; READ CARRY IN
280E       68FB               FBH>AL
280F       2200               DATA>R2
2810       303F               3FH>UH       ;           | ADD. ROUTINE
2811       3800               00H>UL       ; R0+R1>R0  |
2812       2E28               28H>R6       ; Cout>R2-0 | RETURN ADDRESS
2813       2F15               15H>R7
2814       C800               JMP
2815       781F               1FH>AH       ; PUT SUMM IN REG. A
2816       68FC               FCH>AL
2817       5800               R0>DATA
2818       68FB               FBH>AL       ; PUT Cout IN REG C (Carry)
2819       5A00               R2>DATA
281A       3002               02H>UH       ; NEXT OP.
281B       3800               00H>UL
281C       C800               JMP          ; ***************************************************
                              ORG/1480H    ; OP.29 ADDA ****H  ADD A WITH BYTE AT ADDRESS, C
2900       2200               DATA>R2      ; READ MSB ADDRESS
2901       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
2902       3800               00H>UL       ;          |
2903       2C29               29H>R4       ;  IP+1>IP | ADD. RETURN
2904       2D06               06H>R5       ;  IP>ADD  |
2905       C800               JMP          ;          | JMP TO ROUTINE
2906       2300               DATA>R3      ; READ LSB ADDRESS
2907       1200               R2>AH        ; PUT ADDRESS ON ADDRESS BUS
2908       1B00               R3>AL
2909       2000               DATA>R0      ; READ POINTED BYTE
290A       781F               1FH>AH       ; READ REG A
290B       68FC               FCH>AL   
290C       2100               DATA>R1
290D       2A00               00H>R2       ; Put Cin=0
290E       303F               3FH>UH       ;           | ADD. ROUTINE
290F       3800               00H>UL       ; R0+R1>R0  |
2910       2E29               29H>R6       ; Cout>R2-0 | RETURN ADDRESS
2911       2F13               13H>R7
2912       C800               JMP
2913       781F               1FH>AH       ; PUT SUMM IN REG. A
2914       68FC               FCH>AL
2915       5800               R0>DATA
2916       68FB               FBH>AL       ; PUT Cout IN REG C (Carry)
2917       5A00               R2>DATA
2918       3002               02H>UH       ; NEXT OP.
2919       3800               00H>UL
291A       C800               JMP          ; ***************************************************
                              ORG/1500H    ; OP.2A LDA ****H  LOAD A WITH BYTE AT ADDRESS
2A00       2200               DATA>R2      ; READ MSB ADDRESS
2A01       303B               3BH>UH       ;          | ADD. ROUTINE INCREMENT IP
2A02       3800               00H>UL       ;          |
2A03       2C2A               2AH>R4       ;  IP+1>IP | ADD. RETURN
2A04       2D06               06H>R5       ;  IP>ADD  |
2A05       C800               JMP          ;          | JMP TO ROUTINE
2A06       2300               DATA>R3      ; READ LSB ADDRESS
2A07       1200               R2>AH        ; PUT ADDRESS ON ADDRESS BUS
2A08       1B00               R3>AL
2A09       2000               DATA>R0      ; READ POINTED BYTE
2A0A       781F               1FH>AH       ; PUT IN REGISTER A
2A0B       68FC               FCH>AL
2A0C       5800               R0>DATA
2A0D       3002               02H>UH       ; NEXT OP.
2A0E       3800               00H>UL
2A0F       C800               JMP          ; ***************************************************
                              ORG/1580H    ; OP.2B JNEQ ****H  JUMP IF STATUS E (EQUAL) = 1
2B00       781F               1FH>AH       ; LIS BIT E ET MET DANS ENTREE A DE L'ALU.
2B01       68FA               FAH>AL
2B02       2000               DATA>R0
2B03       5000               R0-0>A
2B04       302B               2BH>UH       ; ADDRESSE DU SAUT DANS LE UPROG. SI E=0
2B05       380C               0CH>UL
2B06       C81B               JMP_A=0
2B07       303C               3CH>UH       ; ON PASSE SI ON A EGALITE  E=1    | ADD. ROUTINE
2B08       3800               00H>UL       ;                          IP+1>IP |
2B09       2C02               02H>R4       ;                                  | ADD. RETOUR
2B0A       2D00               00H>R5       ;                                  | PROCHAIN OP.
2B0B       C800               JMP
2B0C       781F               1FH>AH       ; ARRIVAL WHEN E=0, READ IPH
2B0D       68FE               FEH>AL
2B0E       2000               DATA>R0
2B0F       68FF               FFH>AL       ; READ IPL
2B10       2100               DATA>R1      
2B11       1000               R0>AH        ; WRITE IPH:IPL IN AH:AL
2B12       1900               R1>AL
2B13       2200               DATA>R2      ; GET MSB OF JUMP ADDRESS
2B14       303B               3BH>UH       ;          | ADD. ROUTINE
2B15       3800               00H>UL       ;  IP+1>IP |
2B16       2C2B               2BH>R4       ;  IP>ADD  | ADD. RETOUR
2B17       2D19               19H>R5       ;          |
2B18       C800               JMP
2B19       2300               DATA>R3      ; GET LSB OF JUMP ADDRESS
2B1A       781F               1FH>AH       ; MET MSB ADD. DE SAUT DANS IPH
2B1B       68FE               FEH>AL
2B1C       5A00               R2>DATA
2B1D       68FF               FFH>AL       ; MET LSB ADD. DE SAUT DANS IPL
2B1E       5B00               R3>DATA
2B1F       3001               01H>UH       ; Get Pointed OP Code by IP and Execute ( SAUT DU A L'INEGALITE )
2B20       3800               00H>UL
2B21       C800               JMP          ; ***************************************************
                              ORG/1600H    ; OP.2C JEQ ****H  JUMP IF STATUS E (EQUAL) = 1
2C00       781F               1FH>AH       ; LIS BIT E ET MET DANS ENTREE A DE L'ALU.
2C01       68FA               FAH>AL
2C02       2000               DATA>R0
2C03       5000               R0-0>A
2C04       302C               2CH>UH       ; ADDRESSE DU SAUT DANS LE UPROG. SI E=0
2C05       381C               1CH>UL
2C06       C81B               JMP_A=0
2C07       68FE               FEH>AL       ; ICI ON A E=1 ALORS ON PREND L'ADDRESSE  MSB ADD.
2C08       2200               DATA>R2      ; IPH > R2
2C09       68FF               FFH>AL
2C0A       2300               DATA>R3      ; IPL > R3
2C0B       1200               R2>AH        ; IP > ADD
2C0C       1B00               R3>AL
2C0D       2200               DATA>R2      ; TAKE MSB ADD WHERE TO JUMP AND PUT IN R2
2C0E       303B               3BH>UH       ;          | ADD. ROUTINE
2C0F       3800               00H>UL       ;  IP+1>IP |
2C10       2C2C               2CH>R4       ;  IP>ADD  | ADD. RETOUR
2C11       2D13               13H>R5       ;          |
2C12       C800               JMP
2C13       2300               DATA>R3      ; PREND LSB WHERE TO JUMP AND PUT IN R3
2C14       781F               1FH>AH       ; MET MSB ADD. DE SAUT DANS IPH
2C15       68FE               FEH>AL
2C16       5A00               R2>DATA
2C17       68FF               FFH>AL       ; MET LSB ADD. DE SAUT DANS IPL
2C18       5B00               R3>DATA
2C19       3001               01H>UH       ; EXECUTE OP. POINTEE ( SAUT DU A L'EGALITE )
2C1A       3800               00H>UL
2C1B       C800               JMP
2C1C       303C               3CH>UH       ; POINT ARRIVE SI INEGALITE E=0     | ADD. ROUTINE
2C1D       3800               00H>UL       ;                           IP+1>IP |
2C1E       2C02               02H>R4       ;                                   | ADD. RETOUR
2C1F       2D00               00H>R5       ;                                   | PROCHAIN OP.
2C20       C800               JMP          ; ***************************************************
                              ORG/1680H    ; OP.2D CMPA #**H COMPARE A WITH IMMEDIATE VALUE,
2D00       2000               DATA>R0      ; Read Data       UPDATE STATUS E (EQUAL) TO 1 WHEN EQUAL
2D01       781F               1FH>AH       ; Read Reg. A     ELSE E = 0.
2D02       68FC               FCH>AL
2D03       2100               DATA>R1
2D04       5000               R0-0>A
2D05       4130               XNOR R1-0
2D06       5001               R0-1>A
2D07       4131               XNOR R1-1
2D08       5002               R0-2>A
2D09       4132               XNOR R1-2
2D0A       5003               R0-3>A
2D0B       4133               XNOR R1-3
2D0C       5004               R0-4>A
2D0D       4134               XNOR R1-4
2D0E       5005               R0-5>A
2D0F       4135               XNOR R1-5
2D10       5006               R0-6>A
2D11       4136               XNOR R1-6
2D12       5007               R0-7>A
2D13       4137               XNOR R1-7
2D14       6000               Q>R0
2D15       5000               R0-0>A
2D16       4021               AND R0-1
2D17       7001               Q1>A
2D18       4022               AND R0-2
2D19       7002               Q2>A
2D1A       4023               AND R0-3
2D1B       7003               Q3>A
2D1C       4024               AND R0-4
2D1D       7004               Q4>A
2D1E       4025               AND R0-5
2D1F       7005               Q5>A
2D20       4026               AND R0-6
2D21       7006               Q6>A
2D22       4027               AND R0-7
2D23       7007               Q7>A
2D24       4818               A>Q0         ; Place Equal Status in bit position <0>
2D25       2900               00H>R1       ; Put '0' in ALU input A
2D26       5100               R1-0>A
2D27       4819               A>Q1         ; Set Q<7:1> to 0
2D28       481A               A>Q2         ; To have a clean Equal Status Byte
2D29       481B               A>Q3
2D2A       481C               A>Q4
2D2B       481D               A>Q5
2D2C       481E               A>Q6
2D2D       481F               A>Q7
2D2E       6000               Q>R0         ; Move Q byte in R0
2D2F       781F               1FH>AH
2D30       68FA               FAH>AL
2D31       5800               R0>DATA
2D32       3002               02H>UH       ; NEXT OP.
2D33       3800               00H>UL
2D34       C800               JMP          ; ***************************************************
                              ORG/1700H    ; OP.2E ADCA #**H   ACCA+M+C>ACCA     C UPDATED
2E00       2000               DATA>R0      ; READ IMMEDIATE VALUE
2E01       781F               1FH>AH       ; READ REGISTER A
2E02       68FC               FCH>AL
2E03       2100               DATA>R1
2E04       781F               1FH>AH       ; READ CARRY IN
2E05       68FB               FBH>AL
2E06       2200               DATA>R2
2E07       303F               3FH>UH       ;           | ADD. ROUTINE
2E08       3800               00H>UL       ; R0+R1>R0  |
2E09       2E2F               2FH>R6       ; Cout>R2-0 | ADD. RETOUR
2E0A       2F0A               0AH>R7       ;           |
2E0B       C800               JMP          ;           |
2E0C       781F               1FH>AH       ; MET SOMME DANS REG. A
2E0D       68FC               FCH>AL
2E0E       5800               R0>DATA
2E0F       68FB               FBH>AL       ; MET Cout DANS REG C (Carry)
2E10       5A00               R2>DATA
2E11       3002               02H>UH       ; NEXT OP.
2E12       3800               00H>UL
2E13       C800               JMP          ; ***************************************************
                              ORG/1780H    ; OP.2F ADDA #**H   ACCA+M>ACCA     C UPDATED
2F00       2000               DATA>R0      ; READ IMMEDIATE BYTE FOLLOWING OP CODE
2F01       781F               1FH>AH       ; READ REGISTER A
2F02       68FC               FCH>AL
2F03       2100               DATA>R1
2F04       2A00               00H>R2       ; FORCED Cin=0
2F05       303F               3FH>UH       ;           | ROUTINE ADDRESS
2F06       3800               00H>UL       ; R0+R1>R0  |
2F07       2E2F               2FH>R6       ; Cout>R2-0 | RETURN ADDRESS
2F08       2F0A               0AH>R7       ;           |
2F09       C800               JMP          ;           |
2F0A       781F               1FH>AH       ; PUT SUMM INTO A REGISTER
2F0B       68FC               FCH>AL
2F0C       5800               R0>DATA
2F0D       68FB               FBH>AL       ; PUT Cout INTO C (Carry) REGISTER
2F0E       5A00               R2>DATA
2F0F       3002               02H>UH       ; NEXT OP.
2F10       3800               00H>UL
2F11       C800               JMP          ; ***************************************************
                              ORG/1800H    ; OP.30 LDA #**H  LOAD IMMEDIATE VALUE IN REGISTE
3000       2000               DATA>R0      ; READ HEX VALUE TO LOAD
3001       781F               1FH>AH       ; PUT VALUE AT REGISTER A ADDRESS
3002       68FC               FCH>AL
3003       5800               R0>DATA
3004       3002               02H>UH       ; NEXT OP.
3005       3800               00H>UL
3006       C800               JMP          ; ***************************************************
                              ORG/1880H    ; OP.31 STA ****H   STORE REG.A TO ADDRESSE
3100       2200               DATA>R2      ; PREND MSB ADD. DE STOCKAGE DE A
3101       303B               3BH>UH       ;          | ADD. ROUTINE
3102       3800               00H>UL       ;  IP+1>IP |
3103       2C31               31H>R4       ;  IP>ADD  | ADD. RETOUR
3104       2D06               06H>R5       ;          |
3105       C800               JMP
3106       2300               DATA>R3      ; PREND LSB ADD. DE STOCKAGE DE A
3107       781F               1FH>AH       ; LIS LE REGISTRE A
3108       68FC               FCH>AL
3109       2000               DATA>R0
310A       1200               R2>AH        ; MET L'ADDRESSE DE DESTINATION SUR BUS ADDRESSE
310B       1B00               R3>AL
310C       5800               R0>DATA      ; STOCKE REGISTRE A A L'ADDRESSE POINTEE
310D       3002               02H>UH       ; NEXT OP.
310E       3800               00H>UL       ;
310F       C800               JMP          ; ***************************************************
                              ORG/1900H    ; OP.32 JMP ****H JUMP INCONDITIONAL TO ADDRESS
3200       2200               DATA>R2      ; TALE MSB ADDRESS 
3201       303B               3BH>UH       ;          | ADD. ROUTINE
3202       3800               00H>UL       ;  IP+1>IP |
3203       2C32               32H>R4       ;  IP>ADD  | ADD. RETURN
3204       2D06               06H>R5       ;          |
3205       C800               JMP
3206       2300               DATA>R3      ; PREND LSB ADD. DE SAUT INCONDITIONNEL
3207       781F               1FH>AH       ; MET MSB ADD. DE SAUT DANS IPH
3208       68FE               FEH>AL
3209       5A00               R2>DATA
320A       68FF               FFH>AL       ; MET LSB ADD. DE SAUT DANS IPL
320B       5B00               R3>DATA
320C       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
320D       3800               00H>UL
320E       C800               JMP          ; **************************************************
                              ORG/1980H    ; OP.33 ANDA #**H  REGISTER A AND LOGICAL IMMEDIA
3300       2000               DATA>R0      ; TAKE IMMEDIATE BYTE AND STORE IN R0
3301       781F               1FH>AH
3302       68FC               FCH>AL
3303       2100               DATA>R1      ; READ A REGISTER AND STORE IN R1
3304       5000               R0-0>A       ; DO BITWISE AND BBETWEEN R0 AND R1
3305       4120               AND R1-0     ; BUILD RESULT IN Q
3306       5001               R0-1>A
3307       4121               AND R1-1
3308       5002               R0-2>A
3309       4122               AND R1-2
330A       5003               R0-3>A
330B       4123               AND R1-3
330C       5004               R0-4>A
330D       4124               AND R1-4
330E       5005               R0-5>A
330F       4125               AND R1-5
3310       5006               R0-6>A
3311       4126               AND R1-6
3312       5007               R0-7>A
3313       4127               AND R1-7
3314       6000               Q>R0         ; MOVE Q TO R0
3315       5800               R0>DATA      ; STORE R0 INTO REGISTER A
3316       3002               02H>UH       ; NEXT OP.
3317       3800               00H>UL
3318       C800               JMP          ; ***************************************************
                              ORG/1A00H    ; OP.34 ORA #**H   LOGICAL OR BETWEEN REG A AND B
3400       2000               DATA>R0      ; IMMEDIATE BYTE STORED INTO R0
3401       781F               1FH>AH
3402       68FC               FCH>AL
3403       2100               DATA>R1      ; REG A STORED TO R1
3404       5000               R0-0>A       ; BITWISE OR, RESULT STORED IN Q
3405       4108               OR R1-0
3406       5001               R0-1>A
3407       4109               OR R1-1
3408       5002               R0-2>A
3409       410A               OR R1-2
340A       5003               R0-3>A
340B       410B               OR R1-3
340C       5004               R0-4>A
340D       410C               OR R1-4
340E       5005               R0-5>A
340F       410D               OR R1-5
3410       5006               R0-6>A
3411       410E               OR R1-6
3412       5007               R0-7>A
3413       410F               OR R1-7
3414       6000               Q>R0         ; MOVE Q TO R0
3415       5800               R0>DATA      ; STORE RESULT IN REG A
3416       3002               02H>UH       ; NEXT OP.
3417       3800               00H>UL
3418       C800               JMP          ; ***************************************************
                              ORG/1A80H    ; OP.35 XORA #**H   REG A EXCLUSIVE OR immediate 
3500       2000               DATA>R0      ; PREND DONNE
3501       781F               1FH>AH
3502       68FC               FCH>AL
3503       2100               DATA>R1      ; PREND DONNE
3504       5000               R0-0>A
3505       4110               XOR R1-0
3506       5001               R0-1>A
3507       4111               XOR R1-1
3508       5002               R0-2>A
3509       4112               XOR R1-2
350A       5003               R0-3>A
350B       4113               XOR R1-3
350C       5004               R0-4>A
350D       4114               XOR R1-4
350E       5005               R0-5>A
350F       4115               XOR R1-5
3510       5006               R0-6>A
3511       4116               XOR R1-6
3512       5007               R0-7>A
3513       4117               XOR R1-7
3514       6000               Q>R0
3515       5800               R0>DATA      ; MET LE RESULTAT DANS REG. A
3516       3002               02H>UH       ; NEXT OP.
3517       3800               00H>UL
3518       C800               JMP          ; ***************************************************
                              ORG/1B00H    ; OP.36 NOTA   NOT Logic on Register A
3600       781F               1FH>AH
3601       68FC               FCH>AL
3602       2000               DATA>R0      ; Read Register A
3603       5000               R0-0>A       ; Do the NOT operation on all bits
3604       4038               NOT A-0
3605       5001               R0-1>A
3606       4039               NOT A-1
3607       5002               R0-2>A
3608       403A               NOT A-2
3609       5003               R0-3>A
360A       403B               NOT A-3
360B       5004               R0-4>A
360C       403C               NOT A-4
360D       5005               R0-5>A
360E       403D               NOT A-5
360F       5006               R0-6>A
3610       403E               NOT A-6
3611       5007               R0-7>A
3612       403F               NOT A-7
3613       6000               Q>R0
3614       5800               R0>DATA      ; Put result in Register A
3615       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
3616       3800               00H>UL
3617       C800               JMP          ; ***************************************************
                              ORG/1B80H    ; OP.37 INCA  INCREMENT REGISTER A
3700       781F               1FH>AH       ;             C not updated, E updated
3701       68FC               FCH>AL
3702       2000               DATA>R0      ; READ REG. A
3703       2E37               37H>R6       ;
3704       2F08               08H>R7       ; R0+1>R0
3705       303E               3EH>UH       ; Cout>R1-7
3706       3800               00H>UL
3707       C800               JMP
3708       781F               1FH>AH       ; RESULT IN REG. A
3709       68FC               FCH>AL
370A       5800               R0>DATA
                              ;R1-7>A                 ; Carry bit stored in ALU input A
                              ;A>Q0                   ; Place Carry in bit position <0>
                              ;00H>R1                 ; Put '0' in ALU input A
                              ;R1-0>A
                              ;A>Q1                   ; Set Q<7:1> to 0
                              ;A>Q2                   ; To have a clean Carry Status Byte
                              ;A>Q3
                              ;A>Q4
                              ;A>Q5
                              ;A>Q6
                              ;A>Q7
                              ;Q>R0                   ; Move Q byte in R0
                              ;1FH>AH                 ; Store R0 in Carry Status RAM location
                              ;FBH>AL
                              ;R0>DATA
370B       5000               R0-0>A       ; Update E (If result is zero then set E flag )
370C       4009               OR R0-1      ; NOT( 7 OR 6 OR 5 OR 4 OR 3 OR 2 OR 1 OR 0 )
370D       7001               Q1>A
370E       400A               OR R0-2
370F       7002               Q2>A
3710       400B               OR R0-3
3711       7003               Q3>A
3712       400C               OR R0-4
3713       7004               Q4>A
3714       400D               OR R0-5
3715       7005               Q5>A
3716       400E               OR R0-6
3717       7006               Q6>A
3718       400F               OR R0-7
3719       7007               Q7>A
371A       4038               NOT A-0
371B       2900               00H>R1       ; Set Q<7:1> to 0
371C       5100               R1-0>A       ; To have a clean E Status Byte
371D       4819               A>Q1         
371E       481A               A>Q2         
371F       481B               A>Q3
3720       481C               A>Q4
3721       481D               A>Q5
3722       481E               A>Q6
3723       481F               A>Q7
3724       6100               Q>R1         ; Move Q byte in R1
3725       781F               1FH>AH       ; Store E in Equal Status RAM location
3726       68FA               FAH>AL
3727       5900               R1>DATA
3728       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
3729       3800               00H>UL
372A       C800               JMP          ; ******************************************************
                              ORG/1C00H    ; OP.38 LDX #****H  Load Register X with 16 bits 
3800       2200               DATA>R2      ; Take MSB Immediate value
3801       303B               3BH>UH       ;          | ADD. ROUTINE
3802       3800               00H>UL       ;  IP+1>IP |
3803       2C38               38H>R4       ;  IP>ADD  | ADD. RETURN
3804       2D06               06H>R5       ;          |
3805       C800               JMP
3806       2300               DATA>R3      ; Take LSB Immediate value
3807       781F               1FH>AH       ; Put MSB value into register X MSB
3808       68F3               F3H>AL
3809       5A00               R2>DATA
380A       68F4               F4H>AL       ; Put LSB value into register X LSB
380B       5B00               R3>DATA
380C       3002               02H>UH       ; NEXT OP.
380D       3800               00H>UL
380E       C800               JMP          ; ***************************************************
                              ORG/1C80H    ; OP.39 INCX  Increment Register X
3900       781F               1FH>AH       ;             Carry Not Updated
3901       68F4               F4H>AL
3902       2000               DATA>R0      ; Read Reg X LSB
3903       2E39               39H>R6       ;
3904       2F08               08H>R7       ; R0+1>R0
3905       303E               3EH>UH       ; Cout>R1-7
3906       3800               00H>UL
3907       C800               JMP
3908       781F               1FH>AH       ; Put increment result in REG. X LSB
3909       68F4               F4H>AL
390A       5800               R0>DATA
390B       5107               R1-7>A       ; Add 1 to X MSB only if there is a carry
390C       3001               01H>UH       ; If Cout=0 no increment on X MSB
390D       3800               00H>UL       ; and go execute currently pointed OP.
390E       C81B               JMP_A=0      
390F       68F3               F3H>AL       ; If Cout=1 then we increment X MSB
3910       2000               DATA>R0      ; Read X MSB
3911       2E39               39H>R6       ; R0+1>R0
3912       2F16               16H>R7       ; Cout>R1-7, go execute currently pointed OP.
3913       303E               3EH>UH       
3914       3800               00H>UL
3915       C800               JMP
3916       5800               R0>DATA      ; Store X MSB
3917       3001               01H>UH       ; Get Pointed OP Code by IP and Execute
3918       3800               00H>UL
3919       C800               JMP          ; ******************************************************
                              ORG/1D00H    ; 3A00H  ROUTINE R0 - 1 > R0 (No Carry) Return R6
3A00       5000               R0-0>A       ; NOT R0 > R0
3A01       4038               NOT A-0
3A02       5001               R0-1>A
3A03       4039               NOT A-1
3A04       5002               R0-2>A
3A05       403A               NOT A-2
3A06       5003               R0-3>A
3A07       403B               NOT A-3
3A08       5004               R0-4>A
3A09       403C               NOT A-4
3A0A       5005               R0-5>A
3A0B       403D               NOT A-5
3A0C       5006               R0-6>A
3A0D       403E               NOT A-6
3A0E       5007               R0-7>A
3A0F       403F               NOT A-7
3A10       6000               Q>R0
3A11       5000               R0-0>A       ; R0+1>R0
3A12       4818               A>Q0
3A13       4021               AND R0-1
3A14       7001               Q1>A
3A15       4022               AND R0-2
3A16       7002               Q2>A
3A17       4023               AND R0-3
3A18       7003               Q3>A
3A19       4024               AND R0-4
3A1A       7004               Q4>A
3A1B       4025               AND R0-5
3A1C       7005               Q5>A
3A1D       4026               AND R0-6
3A1E       7006               Q6>A
3A1F       4027               AND R0-7
3A20       6100               Q>R1         ; SAVE Cout into R1-7 (Not used)
3A21       7006               Q6>A
3A22       4017               XOR R0-7
3A23       7005               Q5>A
3A24       4016               XOR R0-6
3A25       7004               Q4>A
3A26       4015               XOR R0-5
3A27       7003               Q3>A
3A28       4014               XOR R0-4
3A29       7002               Q2>A
3A2A       4013               XOR R0-3
3A2B       7001               Q1>A
3A2C       4012               XOR R0-2
3A2D       7000               Q0>A
3A2E       4011               XOR R0-1
3A2F       5000               R0-0>A
3A30       4038               NOT A-0
3A31       6000               Q>R0         ; Save temporary result into R0
3A32       5000               R0-0>A       ; NOT R0 > R0
3A33       4038               NOT A-0
3A34       5001               R0-1>A
3A35       4039               NOT A-1
3A36       5002               R0-2>A
3A37       403A               NOT A-2
3A38       5003               R0-3>A
3A39       403B               NOT A-3
3A3A       5004               R0-4>A
3A3B       403C               NOT A-4
3A3C       5005               R0-5>A
3A3D       403D               NOT A-5
3A3E       5006               R0-6>A
3A3F       403E               NOT A-6
3A40       5007               R0-7>A
3A41       403F               NOT A-7
3A42       6000               Q>R0
3A43       0600               R6>UH        ; Return to calling microprogram
3A44       0F00               R7>UL
3A45       C800               JMP          ; ******************************************************
                              ORG/1D80H    ; 3B00H  ROUTINE   * IP+1>IP   IP>ADD.           
3B00       781F               1FH>AH       ;        READ IPL  * RETURN  R4:MSB ADD. R5:LSB ADD.   *
3B01       68FF               FFH>AL       ;        PUT IN R0 *************************************
3B02       2000               DATA>R0      ; INCREMENT (COUT R1-7) R0+1>R0
3B03       5000               R0-0>A
3B04       4818               A>Q0         ; Compute the Carrys
3B05       4021               AND R0-1
3B06       7001               Q1>A
3B07       4022               AND R0-2
3B08       7002               Q2>A
3B09       4023               AND R0-3
3B0A       7003               Q3>A
3B0B       4024               AND R0-4
3B0C       7004               Q4>A
3B0D       4025               AND R0-5
3B0E       7005               Q5>A
3B0F       4026               AND R0-6
3B10       7006               Q6>A
3B11       4027               AND R0-7
3B12       6100               Q>R1         ; Savec Cout in R1-7
3B13       7006               Q6>A
3B14       4017               XOR R0-7
3B15       7005               Q5>A
3B16       4016               XOR R0-6
3B17       7004               Q4>A
3B18       4015               XOR R0-5
3B19       7003               Q3>A
3B1A       4014               XOR R0-4
3B1B       7002               Q2>A
3B1C       4013               XOR R0-3
3B1D       7001               Q1>A
3B1E       4012               XOR R0-2
3B1F       7000               Q0>A
3B20       4011               XOR R0-1
3B21       5000               R0-0>A
3B22       4038               NOT A-0
3B23       6000               Q>R0         ; Save result in R0
3B24       781F               1FH>AH       ; Save increment result in IPL
3B25       68FF               FFH>AL
3B26       5800               R0>DATA
3B27       68FE               FEH>AL       ; Read IPH
3B28       2000               DATA>R0
3B29       5107               R1-7>A       ; Add 1 to IPH if there is a Carry R0 + (R1-7) > R
3B2A       303B               3BH>UH
3B2B       3850               50H>UL       
3B2C       C81B               JMP_A=0      ; If Cin=0 then save by jumping
3B2D       5000               R0-0>A       ; If not we increment R0 containing IPH
3B2E       4818               A>Q0         ; Compute Carrys between bits
3B2F       4021               AND R0-1
3B30       7001               Q1>A
3B31       4022               AND R0-2
3B32       7002               Q2>A
3B33       4023               AND R0-3
3B34       7003               Q3>A
3B35       4024               AND R0-4
3B36       7004               Q4>A
3B37       4025               AND R0-5
3B38       7005               Q5>A
3B39       4026               AND R0-6
3B3A       7006               Q6>A
3B3B       4027               AND R0-7
3B3C       7006               Q6>A
3B3D       4017               XOR R0-7
3B3E       7005               Q5>A
3B3F       4016               XOR R0-6
3B40       7004               Q4>A
3B41       4015               XOR R0-5
3B42       7003               Q3>A
3B43       4014               XOR R0-4
3B44       7002               Q2>A
3B45       4013               XOR R0-3
3B46       7001               Q1>A
3B47       4012               XOR R0-2
3B48       7000               Q0>A
3B49       4011               XOR R0-1
3B4A       5000               R0-0>A
3B4B       4038               NOT A-0
3B4C       6000               Q>R0         ; Increment result in R0
3B4D       781F               1FH>AH       ; Save new IPH value
3B4E       68FE               FEH>AL       
3B4F       5800               R0>DATA
3B50       781F               1FH>AH       ; Read IPH
3B51       68FE               FEH>AL
3B52       2000               DATA>R0
3B53       68FF               FFH>AL       ; Read IPL
3B54       2100               DATA>R1
3B55       1000               R0>AH        ; Put IP in Address Bus
3B56       1900               R1>AL
3B57       0400               R4>UH        ; Return to calling routine
3B58       0D00               R5>UL
3B59       C800               JMP          ; *************************************************
                              ORG/1E00H    ; 3C00H  INCREMENT IP
3C00       781F               1FH>AH       ;        Return  R4:MSB R5:LSB
3C01       68FF               FFH>AL       ; Read IPL
3C02       2000               DATA>R0      
3C03       303E               3EH>UH       ; Address Increment routine
3C04       3800               00H>UL
3C05       2E3C               3CH>R6       ; Address Return
3C06       2F08               08H>R7
3C07       C800               JMP
3C08       781F               1FH>AH       ; Result in IPL
3C09       68FF               FFH>AL
3C0A       5800               R0>DATA
3C0B       68FE               FEH>AL       ; Read IPH
3C0C       2000               DATA>R0
3C0D       303D               3DH>UH       ; Address routine to Add Carry
3C0E       3800               00H>UL
3C0F       2E3C               3CH>R6       ; Return Address
3C10       2F12               12H>R7
3C11       C800               JMP          ; Call routine
3C12       781F               1FH>AH       ; Save result Add Carry
3C13       68FE               FEH>AL
3C14       5800               R0>DATA      
3C15       0400               R4>UH        ; Return Address
3C16       0D00               R5>UL
3C17       C800               JMP          ; ***************************************************
                              ORG/1E80H    ; 3D00H  ADD CARRY   R0+(R1-7)>R0  Cout:R1-7
3D00       5107               R1-7>A       ;                    Return R6:MSB R7:LSB  
3D01       303D               3DH>UH
3D02       3828               28H>UL
3D03       C81B               JMP_A=0      ; If Cin=0 then jump to end to go to return 
3D04       5000               R0-0>A       ; Increment R0
3D05       4818               A>Q0         ; Compute Carry
3D06       4021               AND R0-1
3D07       7001               Q1>A
3D08       4022               AND R0-2
3D09       7002               Q2>A
3D0A       4023               AND R0-3
3D0B       7003               Q3>A
3D0C       4024               AND R0-4
3D0D       7004               Q4>A
3D0E       4025               AND R0-5
3D0F       7005               Q5>A
3D10       4026               AND R0-6
3D11       7006               Q6>A
3D12       4027               AND R0-7
3D13       6100               Q>R1         ; Save Cout in R1-7
3D14       7006               Q6>A
3D15       4017               XOR R0-7
3D16       7005               Q5>A
3D17       4016               XOR R0-6
3D18       7004               Q4>A
3D19       4015               XOR R0-5
3D1A       7003               Q3>A
3D1B       4014               XOR R0-4
3D1C       7002               Q2>A
3D1D       4013               XOR R0-3
3D1E       7001               Q1>A
3D1F       4012               XOR R0-2
3D20       7000               Q0>A
3D21       4011               XOR R0-1
3D22       5000               R0-0>A
3D23       4038               NOT A-0
3D24       6000               Q>R0         ; Save result in R0
3D25       0600               R6>UH        ; Return Address MSB
3D26       0F00               R7>UL        ;                LSB
3D27       C800               JMP          ; End of incrementation
3D28       2900               00H>R1       ; Come here if no incrementation (Cout=0)
3D29       0600               R6>UH        ; Return Address MSB
3D2A       0F00               R7>UL        ;                LSB
3D2B       C800               JMP          ; ***************************************************
                              ORG/1F00H    ; 3E00H  INCREMENT R0+1>R0 Cout:R1-7
3E00       5000               R0-0>A       ;                  Return R6:MSB R7:LSB
3E01       4818               A>Q0         ; Compute Carry
3E02       4021               AND R0-1
3E03       7001               Q1>A
3E04       4022               AND R0-2
3E05       7002               Q2>A
3E06       4023               AND R0-3
3E07       7003               Q3>A
3E08       4024               AND R0-4
3E09       7004               Q4>A
3E0A       4025               AND R0-5
3E0B       7005               Q5>A
3E0C       4026               AND R0-6
3E0D       7006               Q6>A
3E0E       4027               AND R0-7
3E0F       6100               Q>R1         ; Save Cout in R1-7
3E10       7006               Q6>A
3E11       4017               XOR R0-7
3E12       7005               Q5>A
3E13       4016               XOR R0-6
3E14       7004               Q4>A
3E15       4015               XOR R0-5
3E16       7003               Q3>A
3E17       4014               XOR R0-4
3E18       7002               Q2>A
3E19       4013               XOR R0-3
3E1A       7001               Q1>A
3E1B       4012               XOR R0-2
3E1C       7000               Q0>A
3E1D       4011               XOR R0-1
3E1E       5000               R0-0>A
3E1F       4038               NOT A-0
3E20       6000               Q>R0         ; Save result in R0
3E21       0600               R6>UH        ; Return Address MSB
3E22       0F00               R7>UL        ;                LSB
3E23       C800               JMP          ; ***************************************************
                              ORG/1F80H    ; 3F00H  ADDITION R0+R1>R0  Cin:R2-0  Cout:R2-0
3F00       5000               R0-0>A       ;                 Return R6:MSB R7:LSB
3F01       4108               OR R1-0      ;                 Using R3, R4, R5
3F02       5001               R0-1>A
3F03       4109               OR R1-1
3F04       5002               R0-2>A
3F05       410A               OR R1-2
3F06       5003               R0-3>A
3F07       410B               OR R1-3
3F08       5004               R0-4>A
3F09       410C               OR R1-4
3F0A       5005               R0-5>A
3F0B       410D               OR R1-5
3F0C       5006               R0-6>A
3F0D       410E               OR R1-6
3F0E       5007               R0-7>A
3F0F       410F               OR R1-7
3F10       6300               Q>R3
3F11       5000               R0-0>A       ; R0 AND R1 > R4
3F12       4120               AND R1-0
3F13       5001               R0-1>A
3F14       4121               AND R1-1
3F15       5002               R0-2>A
3F16       4122               AND R1-2
3F17       5003               R0-3>A
3F18       4123               AND R1-3
3F19       5004               R0-4>A
3F1A       4124               AND R1-4
3F1B       5005               R0-5>A
3F1C       4125               AND R1-5
3F1D       5006               R0-6>A
3F1E       4126               AND R1-6
3F1F       5007               R0-7>A
3F20       4127               AND R1-7
3F21       6400               Q>R4
3F22       5200               R2-0>A       ; Process Carry  Cin:R2-0
3F23       4320               AND R3-0
3F24       7000               Q0>A
3F25       4408               OR R4-0
3F26       7000               Q0>A
3F27       4321               AND R3-1
3F28       7001               Q1>A
3F29       4409               OR R4-1
3F2A       7001               Q1>A
3F2B       4322               AND R3-2
3F2C       7002               Q2>A
3F2D       440A               OR R4-2
3F2E       7002               Q2>A
3F2F       4323               AND R3-3
3F30       7003               Q3>A
3F31       440B               OR R4-3
3F32       7003               Q3>A
3F33       4324               AND R3-4
3F34       7004               Q4>A
3F35       440C               OR R4-4
3F36       7004               Q4>A
3F37       4325               AND R3-5
3F38       7005               Q5>A
3F39       440D               OR R4-5
3F3A       7005               Q5>A
3F3B       4326               AND R3-6
3F3C       7006               Q6>A
3F3D       440E               OR R4-6
3F3E       7006               Q6>A
3F3F       4327               AND R3-7
3F40       7007               Q7>A
3F41       440F               OR R4-7
3F42       6500               Q>R5
3F43       5200               R2-0>A       ; R0 XOR R1 XOR COUTn
3F44       4010               XOR R0-0
3F45       7000               Q0>A
3F46       4110               XOR R1-0
3F47       5500               R5-0>A
3F48       4011               XOR R0-1
3F49       7001               Q1>A
3F4A       4111               XOR R1-1
3F4B       5501               R5-1>A
3F4C       4012               XOR R0-2
3F4D       7002               Q2>A
3F4E       4112               XOR R1-2
3F4F       5502               R5-2>A
3F50       4013               XOR R0-3
3F51       7003               Q3>A
3F52       4113               XOR R1-3
3F53       5503               R5-3>A
3F54       4014               XOR R0-4
3F55       7004               Q4>A
3F56       4114               XOR R1-4
3F57       5504               R5-4>A
3F58       4015               XOR R0-5
3F59       7005               Q5>A
3F5A       4115               XOR R1-5
3F5B       5505               R5-5>A
3F5C       4016               XOR R0-6
3F5D       7006               Q6>A
3F5E       4116               XOR R1-6
3F5F       5506               R5-6>A
3F60       4017               XOR R0-7
3F61       7007               Q7>A
3F62       4117               XOR R1-7
3F63       6000               Q>R0         ; Save final result in R0
3F64       5507               R5-7>A
3F65       4818               A>Q0         ; Store Carry in Q Bit<0>
3F66       2900               00H>R1
3F67       5100               R1-0>A
3F68       4819               A>Q1         ; Set Q <7:1> to 0
3F69       481A               A>Q2         ; To have a clean carry register
3F6A       481B               A>Q3
3F6B       481C               A>Q4
3F6C       481D               A>Q5
3F6D       481E               A>Q6
3F6E       481F               A>Q7
3F6F       6200               Q>R2         ; Save Carry
3F70       0600               R6>UH        ; Address return MSB
3F71       0F00               R7>UL        ;                LSB
3F72       C800               JMP          ; ***************************************************
Assembly complete
Number of errors = 0
